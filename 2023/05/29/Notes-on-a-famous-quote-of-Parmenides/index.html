<!DOCTYPE html><html lang="en"><head><title>Notes on a famous quote of Parmenides</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.1.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h1>Notes on a famous quote of Parmenides</h1><div class="time">2023-05-29</div><div class="title-margin"></div><blockquote>
<p>注：本文大体是我对未明子视频做的笔记</p>
</blockquote>
<h3 id="「思」与「在」同一"><a href="#「思」与「在」同一" class="headerlink" title="「思」与「在」同一"></a>「思」与「在」同一</h3><p>首先是两种庸俗理解：</p>
<ol>
<li>符合论-科学主义-可知论。此种理解认为当「思」“符合”「在」时，「知识」或「真理」就产生了。</li>
<li>柏拉图主义。此种理解认为理念实存，即 ideas are real，或者说 idealism &#x3D; realism。</li>
</ol>
<p>这两种理解的问题在于它们对“同一”的把握不够彻底，始终认为「思」和「在」之间还有一个界限，因而需要一个 identification （同一化）的过程使得「思」与「在」真正同一。问题首先是，这个界限是哪里来的？以及谁来“驱动”或“执行”这个所谓的 identification 过程呢？</p>
<p>对于第一个问题，我们采取现象学的态度，把这个界限进行悬置，仅仅将它视作场域内的一个要素，然后进行重新解读。对于第二个问题，可以通过以下两种（看似不同实则非常类似的）进路进行解读而得到某种回答。</p>
<h3 id="辩证法解读"><a href="#辩证法解读" class="headerlink" title="辩证法解读"></a>辩证法解读</h3><p>「思」｜「在」之间的界限（“｜”）是一种分裂，它导向了某种康德意义上的不可知论。而在黑格尔辩证法的视角下，它实际上是「在」自身的分裂——「在」由于无法把握自己，在本体论化的过程中失败，于是甩出了认识论试图对本体论进行某种把握，而这个认识论把握的无能，归根结底是本体论的失败。</p>
<p>以下是我对此粗略的图解：</p>
<p><img src="/2023/05/29/Notes-on-a-famous-quote-of-Parmenides/big.png"></p>
<p>小方块们代表着“前本体论”的一些东西，它们尝试“把握自身”、“集合化自身”、“本体论化自身”，于是派出一个特殊的黑方块去尝试执行这个“本体论化程序”。实际上，黑方块就是这个程序，或者说就是「本体论」。「本体论」程序试图把一切“前本体论”的数据统统本体论化，但它在某个节点失败了（比如，在本体论化自身的时候），为了排查原因，需要有另一个程序对这个「本体论」程序本身进行 debug。这个新程序叫「认识论」（以黑圈表示），它代表了「思」，这个「思」与「在」是同质的，它们都由“前本体论”通过上述一系列的辩证运动产生出来。对「本体论」进行“认识”的主体就是与「实体」同质的「主体」。</p>
<p>这个解读的赌注在于，由于「思」和「在」的同质，一切认识论上的无能，都可以回溯到本体论的失败和残缺上去。</p>
<h3 id="现象学解读"><a href="#现象学解读" class="headerlink" title="现象学解读"></a>现象学解读</h3><p>现象学中的「现象」分为「意向性」（主体侧）与「意向对象」（实体侧）。相比辩证法解读来说，现象学的视角更加简明——对自然态度下的表象世界进行悬置（加括号），这一操作能够保留其中所有的规定性和结构。悬置起来的东西成为叫做「在」的「意向对象」，而与之对应的「意向性」成为一个“高阶的”、“超越的”「我思」剩余下来，这个「我思」由于与「在」的同质性，可以切入到被悬置的表现世界「在」中。</p>
<p><img src="/2023/05/29/Notes-on-a-famous-quote-of-Parmenides/pheno.png"></p>
<p>「现象」不仅仅是表象，更是使得表象背后的本质能被「直观」到的必要依赖。本质是一种“去表象化”的现象，而“去表象化”靠「本质直观」实现。</p>
<h3 id="Program-as-Data-的类比（我的冒险尝试）"><a href="#Program-as-Data-的类比（我的冒险尝试）" class="headerlink" title="Program as Data 的类比（我的冒险尝试）"></a>Program as Data 的类比（我的冒险尝试）</h3><p>「思」类比 Program，「在」类比 Data。「思」与「在」的同质性在一些计算机的“本体论层次”是毋庸置疑的，比如最低级的 bits，比如操作系统内的文件系统。在 Functional Programming 中，Program 作为特殊的 Data 能被更高阶的 Program 作为输入和输出把握，比如解释器 interpreters、静态分析器 static analysers、编译器 compilers 等等。例如有一个试图计算系统中所有文件大小的程序<code>P</code>，当它出现故障（本体论化失败）需要 debug 时，一个静态分析器乃至程序员的思考（认识论维度）就会被产生出来，并尝试进行介入修复。当分析器也出问题、或者程序员的思考也无法把问题想明白的时候，就把责任甩回本体论<code>P</code>本身——该考虑它是不是应该被推翻重写、甚至对它的目的进行重新思考了。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li>拉康意义上的性化秩序里，“男性需要女性来告诉自己是什么”与上述辩证法解读的关系是什么？</li>
</ol>
<p class="textAlignRight"><span>↶ </span><a href="/">Home</a><span></span></p></div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXX"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-XXXXXXXXX');</script></html>